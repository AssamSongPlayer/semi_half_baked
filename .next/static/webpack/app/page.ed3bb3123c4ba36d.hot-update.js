"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSupabaseData.ts":
/*!**********************************!*\
  !*** ./hooks/useSupabaseData.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSupabaseData: function() { return /* binding */ useSupabaseData; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n\n\nfunction useSupabaseData(user) {\n    const [songs, setSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [trendingSongs, setTrendingSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [listenedSongs, setListenedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [notListenedSongs, setNotListenedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [playlists, setPlaylists] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [likedSongs, setLikedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Set());\n    const [lastPlayedSong, setLastPlayedSong] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [currentSongStartTime, setCurrentSongStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const currentSongRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    // Convert database song to UI song format\n    const convertDatabaseSong = function(dbSong) {\n        let isLiked = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return {\n            file_id: dbSong.file_id,\n            img_id: dbSong.img_id,\n            name: dbSong.name,\n            artist: dbSong.artist,\n            language: dbSong.language,\n            tags: dbSong.tags,\n            views: dbSong.views,\n            likes: dbSong.likes,\n            id: dbSong.file_id.toString(),\n            image: \"https://images.pexels.com/photos/\".concat(dbSong.img_id, \"/pexels-photo-\").concat(dbSong.img_id, \".jpeg?auto=compress&cs=tinysrgb&w=300\"),\n            isLiked\n        };\n    };\n    // Fetch all songs\n    const fetchSongs = async ()=>{\n        if (!user) {\n            setSongs([]);\n            setTrendingSongs([]);\n            setListenedSongs([]);\n            setNotListenedSongs([]);\n            return;\n        }\n        try {\n            const { data: songsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"songs\").select(\"*\").order(\"views\", {\n                ascending: false\n            });\n            if (error) throw error;\n            let userLikedSongs = new Set();\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", user.id);\n            if (likedData) {\n                userLikedSongs = new Set(likedData.map((item)=>item.song_id));\n                setLikedSongs(userLikedSongs);\n            }\n            // Fetch user's listening history to categorize songs\n            const { data: historyData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"history\").select(\"song_id\").eq(\"user_id\", user.id);\n            const listenedSongIds = new Set((historyData === null || historyData === void 0 ? void 0 : historyData.map((item)=>item.song_id)) || []);\n            const convertedSongs = (songsData === null || songsData === void 0 ? void 0 : songsData.map((song)=>convertDatabaseSong(song, userLikedSongs.has(song.file_id)))) || [];\n            const sortedSongs = [\n                ...convertedSongs\n            ].sort((a, b)=>{\n                const aScore = a.views + a.likes;\n                const bScore = b.views + b.likes;\n                return bScore - aScore;\n            });\n            setSongs(sortedSongs);\n            // Set trending songs (top 10 by views + likes)\n            setTrendingSongs(sortedSongs.slice(0, 10));\n            // Categorize songs into listened and not listened\n            const listened = sortedSongs.filter((song)=>listenedSongIds.has(song.file_id));\n            const notListened = sortedSongs.filter((song)=>!listenedSongIds.has(song.file_id));\n            setListenedSongs(listened);\n            setNotListenedSongs(notListened);\n            const { data: userData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"users\").select(\"last_song_file_id\").eq(\"id\", user.id).single();\n            if (userData === null || userData === void 0 ? void 0 : userData.last_song_file_id) {\n                const lastSong = convertedSongs.find((song)=>song.file_id === userData.last_song_file_id);\n                if (lastSong) {\n                    setLastPlayedSong(lastSong);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching songs:\", error);\n            setSongs([]) // Set empty array on error\n            ;\n            setTrendingSongs([]);\n            setListenedSongs([]);\n            setNotListenedSongs([]);\n        }\n    };\n    // Fetch user playlists\n    const fetchPlaylists = async ()=>{\n        if (!user) {\n            setPlaylists([]);\n            return;\n        }\n        try {\n            const { data: playlistsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").select(\"\\n          id,\\n          name,\\n          playlist_songs (\\n            songs (*)\\n          )\\n        \").eq(\"user_id\", user.id);\n            if (error) throw error;\n            const convertedPlaylists = (playlistsData === null || playlistsData === void 0 ? void 0 : playlistsData.map((playlist)=>{\n                var _playlist_playlist_songs, _playlistSongs_;\n                const playlistSongs = ((_playlist_playlist_songs = playlist.playlist_songs) === null || _playlist_playlist_songs === void 0 ? void 0 : _playlist_playlist_songs.map((ps)=>convertDatabaseSong(ps.songs, likedSongs.has(ps.songs.file_id)))) || [];\n                return {\n                    id: playlist.id.toString(),\n                    name: playlist.name,\n                    songCount: playlistSongs.length,\n                    image: ((_playlistSongs_ = playlistSongs[0]) === null || _playlistSongs_ === void 0 ? void 0 : _playlistSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                    songs: playlistSongs\n                };\n            })) || [];\n            setPlaylists(convertedPlaylists);\n        } catch (error) {\n            console.error(\"Error fetching playlists:\", error);\n        }\n    };\n    // Toggle like song\n    const toggleLike = async (songId)=>{\n        if (!user) return;\n        const songFileId = parseInt(songId);\n        const isCurrentlyLiked = likedSongs.has(songFileId);\n        try {\n            if (isCurrentlyLiked) {\n                // Remove from liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").delete().eq(\"user_id\", user.id).eq(\"song_id\", songFileId);\n                if (error) throw error;\n                // Decrement likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"decrement_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>{\n                    const newSet = new Set(prev);\n                    newSet.delete(songFileId);\n                    return newSet;\n                });\n            } else {\n                // Add to liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"liked_songs\").insert({\n                    user_id: user.id,\n                    song_id: songFileId\n                });\n                if (error) throw error;\n                // Increment likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"increment_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>new Set(prev).add(songFileId));\n            }\n            // Update songs state\n            // Update songs state\n            setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                        ...song,\n                        isLiked: !isCurrentlyLiked,\n                        likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                    } : song));\n            // Update playlists state\n            setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                        ...playlist,\n                        songs: playlist.songs.map((song)=>song.id === songId ? {\n                                ...song,\n                                isLiked: !isCurrentlyLiked,\n                                likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                            } : song)\n                    })));\n        } catch (error) {\n            console.error(\"Error toggling like:\", error);\n        }\n    };\n    // Create playlist\n    const createPlaylist = async (name)=>{\n        if (!user) return;\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").insert({\n                user_id: user.id,\n                name\n            }).select().single();\n            if (error) throw error;\n            const newPlaylist = {\n                id: data.id.toString(),\n                name: data.name,\n                songCount: 0,\n                image: \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                songs: []\n            };\n            setPlaylists((prev)=>[\n                    ...prev,\n                    newPlaylist\n                ]);\n        } catch (error) {\n            console.error(\"Error creating playlist:\", error);\n        }\n    };\n    // Delete playlist\n    const deletePlaylist = async (playlistId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").delete().eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.filter((playlist)=>playlist.id !== playlistId));\n        } catch (error) {\n            console.error(\"Error deleting playlist:\", error);\n        }\n    };\n    // Rename playlist\n    const renamePlaylist = async (playlistId, newName)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlists\").update({\n                name: newName\n            }).eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>playlist.id === playlistId ? {\n                        ...playlist,\n                        name: newName\n                    } : playlist));\n        } catch (error) {\n            console.error(\"Error renaming playlist:\", error);\n        }\n    };\n    // Add song to playlist\n    const addSongToPlaylist = async (playlistId, song)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlist_songs\").insert({\n                playlist_id: parseInt(playlistId),\n                song_id: song.file_id\n            });\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        const songExists = playlist.songs.some((s)=>s.id === song.id);\n                        if (!songExists) {\n                            var _updatedSongs_;\n                            const updatedSongs = [\n                                ...playlist.songs,\n                                song\n                            ];\n                            return {\n                                ...playlist,\n                                songs: updatedSongs,\n                                songCount: updatedSongs.length,\n                                image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || playlist.image\n                            };\n                        }\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error adding song to playlist:\", error);\n        }\n    };\n    // Remove song from playlist\n    const removeSongFromPlaylist = async (playlistId, songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"playlist_songs\").delete().eq(\"playlist_id\", parseInt(playlistId)).eq(\"song_id\", parseInt(songId));\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        var _updatedSongs_;\n                        const updatedSongs = playlist.songs.filter((song)=>song.id !== songId);\n                        return {\n                            ...playlist,\n                            songs: updatedSongs,\n                            songCount: updatedSongs.length,\n                            image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\"\n                        };\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error removing song from playlist:\", error);\n        }\n    };\n    // Update last song in user profile\n    const updateLastSong = async (songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.from(\"users\").update({\n                last_song_file_id: parseInt(songId)\n            }).eq(\"id\", user.id);\n            if (error) throw error;\n        } catch (error) {\n            console.error(\"Error updating last song:\", error);\n        }\n    };\n    // Record listening history with proper time tracking\n    const recordListeningHistory = async (songId)=>{\n        if (!user) return;\n        // If there's a previous song playing, record its listening time\n        if (currentSongRef.current && currentSongStartTime) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: user.id,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history:\", error);\n                    } else {\n                        console.log(\"✅ History updated: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording previous song history:\", error);\n                }\n            }\n        }\n        // Set new song as current\n        currentSongRef.current = songId;\n        setCurrentSongStartTime(new Date());\n        // Move song from not listened to listened if it's the first time\n        const songFileId = parseInt(songId);\n        const songToMove = notListenedSongs.find((song)=>song.file_id === songFileId);\n        if (songToMove) {\n            setListenedSongs((prev)=>[\n                    ...prev,\n                    songToMove\n                ]);\n            setNotListenedSongs((prev)=>prev.filter((song)=>song.file_id !== songFileId));\n        }\n        // Update last song in user profile\n        await updateLastSong(songId);\n        try {\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"increment_song_views\", {\n                song_file_id: parseInt(songId)\n            });\n        } catch (error) {\n            console.error(\"Error incrementing song views:\", error);\n        }\n    };\n    // Stop current song tracking (when player is closed)\n    const stopCurrentSongTracking = async ()=>{\n        if (currentSongRef.current && currentSongStartTime && user) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_1__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: user.id,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history on stop:\", error);\n                    } else {\n                        console.log(\"\\uD83D\\uDED1 History updated on stop: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording final song history:\", error);\n                }\n            }\n        }\n        currentSongRef.current = null;\n        setCurrentSongStartTime(null);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(()=>{\n        const loadData = async ()=>{\n            setLoading(true);\n            try {\n                await Promise.all([\n                    fetchSongs(),\n                    fetchPlaylists()\n                ]);\n            } catch (error) {\n                console.error(\"Error loading data:\", error);\n            } finally{\n                setLoading(false);\n            }\n        };\n        if (user) {\n            loadData();\n        } else {\n            // Reset data when user logs out\n            setSongs([]);\n            setTrendingSongs([]);\n            setListenedSongs([]);\n            setNotListenedSongs([]);\n            setPlaylists([]);\n            setLikedSongs(new Set());\n            setLastPlayedSong(null);\n            setLoading(false);\n        }\n    }, [\n        user\n    ]);\n    return {\n        songs,\n        trendingSongs,\n        listenedSongs,\n        notListenedSongs,\n        playlists,\n        likedSongs: songs.filter((song)=>song.isLiked),\n        lastPlayedSong,\n        loading,\n        toggleLike,\n        createPlaylist,\n        deletePlaylist,\n        renamePlaylist,\n        addSongToPlaylist,\n        removeSongFromPlaylist,\n        recordListeningHistory,\n        stopCurrentSongTracking,\n        refreshData: ()=>{\n            fetchSongs();\n            fetchPlaylists();\n        }\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW1EO0FBRXNCO0FBR2xFLFNBQVNJLGdCQUFnQkMsSUFBaUI7SUFDL0MsTUFBTSxDQUFDQyxPQUFPQyxTQUFTLEdBQUdQLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsTUFBTSxDQUFDUSxlQUFlQyxpQkFBaUIsR0FBR1QsK0NBQVFBLENBQVMsRUFBRTtJQUM3RCxNQUFNLENBQUNVLGVBQWVDLGlCQUFpQixHQUFHWCwrQ0FBUUEsQ0FBUyxFQUFFO0lBQzdELE1BQU0sQ0FBQ1ksa0JBQWtCQyxvQkFBb0IsR0FBR2IsK0NBQVFBLENBQVMsRUFBRTtJQUNuRSxNQUFNLENBQUNjLFdBQVdDLGFBQWEsR0FBR2YsK0NBQVFBLENBQWEsRUFBRTtJQUN6RCxNQUFNLENBQUNnQixZQUFZQyxjQUFjLEdBQUdqQiwrQ0FBUUEsQ0FBYyxJQUFJa0I7SUFDOUQsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHcEIsK0NBQVFBLENBQWM7SUFDbEUsTUFBTSxDQUFDcUIsU0FBU0MsV0FBVyxHQUFHdEIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDdUIsc0JBQXNCQyx3QkFBd0IsR0FBR3hCLCtDQUFRQSxDQUFjO0lBQzlFLE1BQU15QixpQkFBaUJ2Qiw2Q0FBTUEsQ0FBZ0I7SUFFN0MsMENBQTBDO0lBQzFDLE1BQU13QixzQkFBc0IsU0FBQ0M7WUFBc0JDLDJFQUFtQjtlQUFpQjtZQUNyRkMsU0FBU0YsT0FBT0UsT0FBTztZQUN2QkMsUUFBUUgsT0FBT0csTUFBTTtZQUNyQkMsTUFBTUosT0FBT0ksSUFBSTtZQUNqQkMsUUFBUUwsT0FBT0ssTUFBTTtZQUNyQkMsVUFBVU4sT0FBT00sUUFBUTtZQUN6QkMsTUFBTVAsT0FBT08sSUFBSTtZQUNqQkMsT0FBT1IsT0FBT1EsS0FBSztZQUNuQkMsT0FBT1QsT0FBT1MsS0FBSztZQUNuQkMsSUFBSVYsT0FBT0Us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QUFPLEdBQUc7UUFDekIzRix3QkFBd0I7SUFDMUI7SUFFQXZCLGdEQUFTQSxDQUFDO1FBQ1IsTUFBTThILFdBQVc7WUFDZnpHLFdBQVc7WUFDWCxJQUFJO2dCQUNGLE1BQU0wRyxRQUFRQyxHQUFHLENBQUM7b0JBQUN6RjtvQkFBY21DO2lCQUFpQjtZQUNwRCxFQUFFLE9BQU9oQyxPQUFPO2dCQUNkK0IsUUFBUS9CLEtBQUssQ0FBQyx1QkFBdUJBO1lBQ3ZDLFNBQVU7Z0JBQ1JyQixXQUFXO1lBQ2I7UUFDRjtRQUVBLElBQUlqQixNQUFNO1lBQ1IwSDtRQUNGLE9BQU87WUFDTCxnQ0FBZ0M7WUFDaEN4SCxTQUFTLEVBQUU7WUFDWEUsaUJBQWlCLEVBQUU7WUFDbkJFLGlCQUFpQixFQUFFO1lBQ25CRSxvQkFBb0IsRUFBRTtZQUN0QkUsYUFBYSxFQUFFO1lBQ2ZFLGNBQWMsSUFBSUM7WUFDbEJFLGtCQUFrQjtZQUNsQkUsV0FBVztRQUNiO0lBQ0YsR0FBRztRQUFDakI7S0FBSztJQUVULE9BQU87UUFDTEM7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUU7UUFDQUUsWUFBWVYsTUFBTTZELE1BQU0sQ0FBQ1YsQ0FBQUEsT0FBUUEsS0FBSzdCLE9BQU87UUFDN0NUO1FBQ0FFO1FBQ0ErRDtRQUNBZTtRQUNBRTtRQUNBRTtRQUNBRztRQUNBTTtRQUNBRTtRQUNBWTtRQUNBSSxhQUFhO1lBQ1gxRjtZQUNBbUM7UUFDRjtJQUNGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlU3VwYWJhc2VEYXRhLnRzP2FiZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJ1xuaW1wb3J0IHsgc3VwYWJhc2UsIERhdGFiYXNlU29uZywgRGF0YWJhc2VQbGF5bGlzdCB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJ1xuaW1wb3J0IHsgU29uZywgUGxheWxpc3QgfSBmcm9tICdAL3R5cGVzJ1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlU3VwYWJhc2VEYXRhKHVzZXI6IFVzZXIgfCBudWxsKSB7XG4gIGNvbnN0IFtzb25ncywgc2V0U29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgY29uc3QgW3RyZW5kaW5nU29uZ3MsIHNldFRyZW5kaW5nU29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgY29uc3QgW2xpc3RlbmVkU29uZ3MsIHNldExpc3RlbmVkU29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgY29uc3QgW25vdExpc3RlbmVkU29uZ3MsIHNldE5vdExpc3RlbmVkU29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgY29uc3QgW3BsYXlsaXN0cywgc2V0UGxheWxpc3RzXSA9IHVzZVN0YXRlPFBsYXlsaXN0W10+KFtdKVxuICBjb25zdCBbbGlrZWRTb25ncywgc2V0TGlrZWRTb25nc10gPSB1c2VTdGF0ZTxTZXQ8bnVtYmVyPj4obmV3IFNldCgpKVxuICBjb25zdCBbbGFzdFBsYXllZFNvbmcsIHNldExhc3RQbGF5ZWRTb25nXSA9IHVzZVN0YXRlPFNvbmcgfCBudWxsPihudWxsKVxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSlcbiAgY29uc3QgW2N1cnJlbnRTb25nU3RhcnRUaW1lLCBzZXRDdXJyZW50U29uZ1N0YXJ0VGltZV0gPSB1c2VTdGF0ZTxEYXRlIHwgbnVsbD4obnVsbClcbiAgY29uc3QgY3VycmVudFNvbmdSZWYgPSB1c2VSZWY8c3RyaW5nIHwgbnVsbD4obnVsbClcblxuICAvLyBDb252ZXJ0IGRhdGFiYXNlIHNvbmcgdG8gVUkgc29uZyBmb3JtYXRcbiAgY29uc3QgY29udmVydERhdGFiYXNlU29uZyA9IChkYlNvbmc6IERhdGFiYXNlU29uZywgaXNMaWtlZDogYm9vbGVhbiA9IGZhbHNlKTogU29uZyA9PiAoe1xuICAgIGZpbGVfaWQ6IGRiU29uZy5maWxlX2lkLFxuICAgIGltZ19pZDogZGJTb25nLmltZ19pZCxcbiAgICBuYW1lOiBkYlNvbmcubmFtZSxcbiAgICBhcnRpc3Q6IGRiU29uZy5hcnRpc3QsXG4gICAgbGFuZ3VhZ2U6IGRiU29uZy5sYW5ndWFnZSxcbiAgICB0YWdzOiBkYlNvbmcudGFncyxcbiAgICB2aWV3czogZGJTb25nLnZpZXdzLFxuICAgIGxpa2VzOiBkYlNvbmcubGlrZXMsXG4gICAgaWQ6IGRiU29uZy5maWxlX2lkLnRvU3RyaW5nKCksXG4gICAgaW1hZ2U6IGBodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8ke2RiU29uZy5pbWdfaWR9L3BleGVscy1waG90by0ke2RiU29uZy5pbWdfaWR9LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMGAsXG4gICAgaXNMaWtlZFxuICB9KVxuXG4gIC8vIEZldGNoIGFsbCBzb25nc1xuICBjb25zdCBmZXRjaFNvbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0U29uZ3MoW10pXG4gICAgICBzZXRUcmVuZGluZ1NvbmdzKFtdKVxuICAgICAgc2V0TGlzdGVuZWRTb25ncyhbXSlcbiAgICAgIHNldE5vdExpc3RlbmVkU29uZ3MoW10pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZGF0YTogc29uZ3NEYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnKicpXG4gICAgICAgIC5vcmRlcigndmlld3MnLCB7IGFzY2VuZGluZzogZmFsc2UgfSlcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBsZXQgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0PG51bWJlcj4oKVxuICAgICAgXG4gICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgLnNlbGVjdCgnc29uZ19pZCcpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICBcbiAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0KGxpa2VkRGF0YS5tYXAoaXRlbSA9PiBpdGVtLnNvbmdfaWQpKVxuICAgICAgICBzZXRMaWtlZFNvbmdzKHVzZXJMaWtlZFNvbmdzKVxuICAgICAgfVxuXG4gICAgICAvLyBGZXRjaCB1c2VyJ3MgbGlzdGVuaW5nIGhpc3RvcnkgdG8gY2F0ZWdvcml6ZSBzb25nc1xuICAgICAgY29uc3QgeyBkYXRhOiBoaXN0b3J5RGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2hpc3RvcnknKVxuICAgICAgICAuc2VsZWN0KCdzb25nX2lkJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgICAgY29uc3QgbGlzdGVuZWRTb25nSWRzID0gbmV3IFNldChoaXN0b3J5RGF0YT8ubWFwKGl0ZW0gPT4gaXRlbS5zb25nX2lkKSB8fCBbXSlcbiAgICAgIGNvbnN0IGNvbnZlcnRlZFNvbmdzID0gc29uZ3NEYXRhPy5tYXAoc29uZyA9PiBcbiAgICAgICAgY29udmVydERhdGFiYXNlU29uZyhzb25nLCB1c2VyTGlrZWRTb25ncy5oYXMoc29uZy5maWxlX2lkKSlcbiAgICAgICkgfHwgW11cblxuICAgICAgY29uc3Qgc29ydGVkU29uZ3MgPSBbLi4uY29udmVydGVkU29uZ3NdLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgYVNjb3JlID0gYS52aWV3cyArIGEubGlrZXM7XG4gICAgICAgIGNvbnN0IGJTY29yZSA9IGIudmlld3MgKyBiLmxpa2VzO1xuICAgICAgICByZXR1cm4gYlNjb3JlIC0gYVNjb3JlO1xuICAgICAgfSk7XG5cbiAgICAgIHNldFNvbmdzKHNvcnRlZFNvbmdzKTtcblxuICAgICAgLy8gU2V0IHRyZW5kaW5nIHNvbmdzICh0b3AgMTAgYnkgdmlld3MgKyBsaWtlcylcbiAgICAgIHNldFRyZW5kaW5nU29uZ3Moc29ydGVkU29uZ3Muc2xpY2UoMCwgMTApKVxuXG4gICAgICAvLyBDYXRlZ29yaXplIHNvbmdzIGludG8gbGlzdGVuZWQgYW5kIG5vdCBsaXN0ZW5lZFxuICAgICAgY29uc3QgbGlzdGVuZWQgPSBzb3J0ZWRTb25ncy5maWx0ZXIoc29uZyA9PiBsaXN0ZW5lZFNvbmdJZHMuaGFzKHNvbmcuZmlsZV9pZCkpXG4gICAgICBjb25zdCBub3RMaXN0ZW5lZCA9IHNvcnRlZFNvbmdzLmZpbHRlcihzb25nID0+ICFsaXN0ZW5lZFNvbmdJZHMuaGFzKHNvbmcuZmlsZV9pZCkpXG4gICAgICBcbiAgICAgIHNldExpc3RlbmVkU29uZ3MobGlzdGVuZWQpXG4gICAgICBzZXROb3RMaXN0ZW5lZFNvbmdzKG5vdExpc3RlbmVkKVxuICAgICAgY29uc3QgeyBkYXRhOiB1c2VyRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnNlbGVjdCgnbGFzdF9zb25nX2ZpbGVfaWQnKVxuICAgICAgICAuZXEoJ2lkJywgdXNlci5pZClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmICh1c2VyRGF0YT8ubGFzdF9zb25nX2ZpbGVfaWQpIHtcbiAgICAgICAgY29uc3QgbGFzdFNvbmcgPSBjb252ZXJ0ZWRTb25ncy5maW5kKHNvbmcgPT4gc29uZy5maWxlX2lkID09PSB1c2VyRGF0YS5sYXN0X3NvbmdfZmlsZV9pZClcbiAgICAgICAgaWYgKGxhc3RTb25nKSB7XG4gICAgICAgICAgc2V0TGFzdFBsYXllZFNvbmcobGFzdFNvbmcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgc29uZ3M6JywgZXJyb3IpXG4gICAgICBzZXRTb25ncyhbXSkgLy8gU2V0IGVtcHR5IGFycmF5IG9uIGVycm9yXG4gICAgICBzZXRUcmVuZGluZ1NvbmdzKFtdKVxuICAgICAgc2V0TGlzdGVuZWRTb25ncyhbXSlcbiAgICAgIHNldE5vdExpc3RlbmVkU29uZ3MoW10pXG4gICAgfVxuICB9XG5cbiAgLy8gRmV0Y2ggdXNlciBwbGF5bGlzdHNcbiAgY29uc3QgZmV0Y2hQbGF5bGlzdHMgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCF1c2VyKSB7XG4gICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhOiBwbGF5bGlzdHNEYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC5zZWxlY3QoYFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgcGxheWxpc3Rfc29uZ3MgKFxuICAgICAgICAgICAgc29uZ3MgKCopXG4gICAgICAgICAgKVxuICAgICAgICBgKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIGNvbnN0IGNvbnZlcnRlZFBsYXlsaXN0czogUGxheWxpc3RbXSA9IHBsYXlsaXN0c0RhdGE/Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgIGNvbnN0IHBsYXlsaXN0U29uZ3MgPSBwbGF5bGlzdC5wbGF5bGlzdF9zb25ncz8ubWFwKChwczogYW55KSA9PiBcbiAgICAgICAgICBjb252ZXJ0RGF0YWJhc2VTb25nKHBzLnNvbmdzLCBsaWtlZFNvbmdzLmhhcyhwcy5zb25ncy5maWxlX2lkKSlcbiAgICAgICAgKSB8fCBbXVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaWQ6IHBsYXlsaXN0LmlkLnRvU3RyaW5nKCksXG4gICAgICAgICAgbmFtZTogcGxheWxpc3QubmFtZSxcbiAgICAgICAgICBzb25nQ291bnQ6IHBsYXlsaXN0U29uZ3MubGVuZ3RoLFxuICAgICAgICAgIGltYWdlOiBwbGF5bGlzdFNvbmdzWzBdPy5pbWFnZSB8fCAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnLFxuICAgICAgICAgIHNvbmdzOiBwbGF5bGlzdFNvbmdzXG4gICAgICAgIH1cbiAgICAgIH0pIHx8IFtdXG5cbiAgICAgIHNldFBsYXlsaXN0cyhjb252ZXJ0ZWRQbGF5bGlzdHMpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHBsYXlsaXN0czonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBUb2dnbGUgbGlrZSBzb25nXG4gIGNvbnN0IHRvZ2dsZUxpa2UgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgaWYgKCF1c2VyKSByZXR1cm47XG5cbiAgY29uc3Qgc29uZ0ZpbGVJZCA9IHBhcnNlSW50KHNvbmdJZCk7XG4gIGNvbnN0IGlzQ3VycmVudGx5TGlrZWQgPSBsaWtlZFNvbmdzLmhhcyhzb25nRmlsZUlkKTtcblxuICB0cnkge1xuICAgIGlmIChpc0N1cnJlbnRseUxpa2VkKSB7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBsaWtlZF9zb25nc1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgIC5lcSgnc29uZ19pZCcsIHNvbmdGaWxlSWQpO1xuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuXG4gICAgICAvLyBEZWNyZW1lbnQgbGlrZXNcbiAgICAgIGF3YWl0IHN1cGFiYXNlLnJwYygnZGVjcmVtZW50X3NvbmdfbGlrZXMnLCB7IHNvbmdfZmlsZV9pZDogc29uZ0ZpbGVJZCB9KTtcblxuICAgICAgc2V0TGlrZWRTb25ncyhwcmV2ID0+IHtcbiAgICAgICAgY29uc3QgbmV3U2V0ID0gbmV3IFNldChwcmV2KTtcbiAgICAgICAgbmV3U2V0LmRlbGV0ZShzb25nRmlsZUlkKTtcbiAgICAgICAgcmV0dXJuIG5ld1NldDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBZGQgdG8gbGlrZWRfc29uZ3NcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdsaWtlZF9zb25ncycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgc29uZ19pZDogc29uZ0ZpbGVJZCxcbiAgICAgICAgfSk7XG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICAgIC8vIEluY3JlbWVudCBsaWtlc1xuICAgICAgYXdhaXQgc3VwYWJhc2UucnBjKCdpbmNyZW1lbnRfc29uZ19saWtlcycsIHsgc29uZ19maWxlX2lkOiBzb25nRmlsZUlkIH0pO1xuXG4gICAgICBzZXRMaWtlZFNvbmdzKHByZXYgPT4gbmV3IFNldChwcmV2KS5hZGQoc29uZ0ZpbGVJZCkpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBzb25ncyBzdGF0ZVxuICAgIC8vIFVwZGF0ZSBzb25ncyBzdGF0ZVxuc2V0U29uZ3MocHJldlNvbmdzID0+XG4gIHByZXZTb25ncy5tYXAoc29uZyA9PlxuICAgIHNvbmcuaWQgPT09IHNvbmdJZFxuICAgICAgPyB7XG4gICAgICAgICAgLi4uc29uZyxcbiAgICAgICAgICBpc0xpa2VkOiAhaXNDdXJyZW50bHlMaWtlZCxcbiAgICAgICAgICBsaWtlczogc29uZy5saWtlcyArIChpc0N1cnJlbnRseUxpa2VkID8gLTEgOiAxKSxcbiAgICAgICAgfVxuICAgICAgOiBzb25nXG4gIClcbik7XG5cblxuICAgIC8vIFVwZGF0ZSBwbGF5bGlzdHMgc3RhdGVcbiAgICBzZXRQbGF5bGlzdHMocHJldlBsYXlsaXN0cyA9PlxuICAgICAgcHJldlBsYXlsaXN0cy5tYXAocGxheWxpc3QgPT4gKHtcbiAgICAgICAgLi4ucGxheWxpc3QsXG4gICAgICAgIHNvbmdzOiBwbGF5bGlzdC5zb25ncy5tYXAoc29uZyA9PlxuICAgICAgICAgIHNvbmcuaWQgPT09IHNvbmdJZFxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgLi4uc29uZyxcbiAgICAgICAgICAgICAgICBpc0xpa2VkOiAhaXNDdXJyZW50bHlMaWtlZCxcbiAgICAgICAgICAgICAgICBsaWtlczogc29uZy5saWtlcyArIChpc0N1cnJlbnRseUxpa2VkID8gLTEgOiAxKSxcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBzb25nXG4gICAgICAgICksXG4gICAgICB9KSlcbiAgICApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHRvZ2dsaW5nIGxpa2U6JywgZXJyb3IpO1xuICB9XG59O1xuXG5cbiAgLy8gQ3JlYXRlIHBsYXlsaXN0XG4gIGNvbnN0IGNyZWF0ZVBsYXlsaXN0ID0gYXN5bmMgKG5hbWU6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC5pbnNlcnQoe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgbmFtZVxuICAgICAgICB9KVxuICAgICAgICAuc2VsZWN0KClcbiAgICAgICAgLnNpbmdsZSgpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgY29uc3QgbmV3UGxheWxpc3Q6IFBsYXlsaXN0ID0ge1xuICAgICAgICBpZDogZGF0YS5pZC50b1N0cmluZygpLFxuICAgICAgICBuYW1lOiBkYXRhLm5hbWUsXG4gICAgICAgIHNvbmdDb3VudDogMCxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8xNzYzMDc1L3BleGVscy1waG90by0xNzYzMDc1LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMCcsXG4gICAgICAgIHNvbmdzOiBbXVxuICAgICAgfVxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBbLi4ucHJldiwgbmV3UGxheWxpc3RdKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBEZWxldGUgcGxheWxpc3RcbiAgY29uc3QgZGVsZXRlUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLmRlbGV0ZSgpXG4gICAgICAgIC5lcSgnaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBwcmV2LmZpbHRlcihwbGF5bGlzdCA9PiBwbGF5bGlzdC5pZCAhPT0gcGxheWxpc3RJZCkpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRlbGV0aW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmFtZSBwbGF5bGlzdFxuICBjb25zdCByZW5hbWVQbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIG5ld05hbWU6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0cycpXG4gICAgICAgIC51cGRhdGUoeyBuYW1lOiBuZXdOYW1lIH0pXG4gICAgICAgIC5lcSgnaWQnLCBwYXJzZUludChwbGF5bGlzdElkKSlcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBzZXRQbGF5bGlzdHMocHJldiA9PiBcbiAgICAgICAgcHJldi5tYXAocGxheWxpc3QgPT4gXG4gICAgICAgICAgcGxheWxpc3QuaWQgPT09IHBsYXlsaXN0SWQgXG4gICAgICAgICAgICA/IHsgLi4ucGxheWxpc3QsIG5hbWU6IG5ld05hbWUgfVxuICAgICAgICAgICAgOiBwbGF5bGlzdFxuICAgICAgICApXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbmFtaW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZCBzb25nIHRvIHBsYXlsaXN0XG4gIGNvbnN0IGFkZFNvbmdUb1BsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZywgc29uZzogU29uZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3BsYXlsaXN0X3NvbmdzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgcGxheWxpc3RfaWQ6IHBhcnNlSW50KHBsYXlsaXN0SWQpLFxuICAgICAgICAgIHNvbmdfaWQ6IHNvbmcuZmlsZV9pZFxuICAgICAgICB9KVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgICAgaWYgKHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkKSB7XG4gICAgICAgICAgICBjb25zdCBzb25nRXhpc3RzID0gcGxheWxpc3Quc29uZ3Muc29tZShzID0+IHMuaWQgPT09IHNvbmcuaWQpXG4gICAgICAgICAgICBpZiAoIXNvbmdFeGlzdHMpIHtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlZFNvbmdzID0gWy4uLnBsYXlsaXN0LnNvbmdzLCBzb25nXVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgICAgICAgIHNvbmdzOiB1cGRhdGVkU29uZ3MsXG4gICAgICAgICAgICAgICAgc29uZ0NvdW50OiB1cGRhdGVkU29uZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGltYWdlOiB1cGRhdGVkU29uZ3NbMF0/LmltYWdlIHx8IHBsYXlsaXN0LmltYWdlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBsYXlsaXN0XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBzb25nIHRvIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlbW92ZSBzb25nIGZyb20gcGxheWxpc3RcbiAgY29uc3QgcmVtb3ZlU29uZ0Zyb21QbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcsIHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3Rfc29uZ3MnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdwbGF5bGlzdF9pZCcsIHBhcnNlSW50KHBsYXlsaXN0SWQpKVxuICAgICAgICAuZXEoJ3NvbmdfaWQnLCBwYXJzZUludChzb25nSWQpKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiB7XG4gICAgICAgICAgaWYgKHBsYXlsaXN0LmlkID09PSBwbGF5bGlzdElkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkU29uZ3MgPSBwbGF5bGlzdC5zb25ncy5maWx0ZXIoc29uZyA9PiBzb25nLmlkICE9PSBzb25nSWQpXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAuLi5wbGF5bGlzdCxcbiAgICAgICAgICAgICAgc29uZ3M6IHVwZGF0ZWRTb25ncyxcbiAgICAgICAgICAgICAgc29uZ0NvdW50OiB1cGRhdGVkU29uZ3MubGVuZ3RoLFxuICAgICAgICAgICAgICBpbWFnZTogdXBkYXRlZFNvbmdzWzBdPy5pbWFnZSB8fCAnaHR0cHM6Ly9pbWFnZXMucGV4ZWxzLmNvbS9waG90b3MvMTc2MzA3NS9wZXhlbHMtcGhvdG8tMTc2MzA3NS5qcGVnP2F1dG89Y29tcHJlc3MmY3M9dGlueXNyZ2Imdz0zMDAnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwbGF5bGlzdFxuICAgICAgICB9KVxuICAgICAgKVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBzb25nIGZyb20gcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRlIGxhc3Qgc29uZyBpbiB1c2VyIHByb2ZpbGVcbiAgY29uc3QgdXBkYXRlTGFzdFNvbmcgPSBhc3luYyAoc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgIC51cGRhdGUoeyBsYXN0X3NvbmdfZmlsZV9pZDogcGFyc2VJbnQoc29uZ0lkKSB9KVxuICAgICAgICAuZXEoJ2lkJywgdXNlci5pZClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBsYXN0IHNvbmc6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVjb3JkIGxpc3RlbmluZyBoaXN0b3J5IHdpdGggcHJvcGVyIHRpbWUgdHJhY2tpbmdcbiAgY29uc3QgcmVjb3JkTGlzdGVuaW5nSGlzdG9yeSA9IGFzeW5jIChzb25nSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICAvLyBJZiB0aGVyZSdzIGEgcHJldmlvdXMgc29uZyBwbGF5aW5nLCByZWNvcmQgaXRzIGxpc3RlbmluZyB0aW1lXG4gICAgICBpZiAoY3VycmVudFNvbmdSZWYuY3VycmVudCAmJiBjdXJyZW50U29uZ1N0YXJ0VGltZSkge1xuICAgIGNvbnN0IGVuZFRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgIGNvbnN0IG1pbnV0ZXNMaXN0ZW5lZCA9IChlbmRUaW1lLmdldFRpbWUoKSAtIGN1cnJlbnRTb25nU3RhcnRUaW1lLmdldFRpbWUoKSkgLyAoMTAwMCAqIDYwKTtcblxuICAgIGlmIChtaW51dGVzTGlzdGVuZWQgPiAwLjEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLnJvdW5kKG1pbnV0ZXNMaXN0ZW5lZCAqIDEwMCkgLyAxMDA7XG4gICAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygndXBzZXJ0X2hpc3RvcnlfbWludXRlcycsIHtcbiAgICAgICAgICB1c2VyX3V1aWQ6IHVzZXIuaWQsXG4gICAgICAgICAgc29uZ19maWxlX2lkOiBwYXJzZUludChjdXJyZW50U29uZ1JlZi5jdXJyZW50KSxcbiAgICAgICAgICBtaW51dGVzOiBtaW51dGVzLFxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgcmVjb3JkaW5nIHNvbmcgaGlzdG9yeTonLCBlcnJvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYOKchSBIaXN0b3J5IHVwZGF0ZWQ6ICske21pbnV0ZXN9IG1pbnMgZm9yIHNvbmcgJHtjdXJyZW50U29uZ1JlZi5jdXJyZW50fWApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWNvcmRpbmcgcHJldmlvdXMgc29uZyBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuXG4gICAgLy8gU2V0IG5ldyBzb25nIGFzIGN1cnJlbnRcbiAgICBjdXJyZW50U29uZ1JlZi5jdXJyZW50ID0gc29uZ0lkXG4gICAgc2V0Q3VycmVudFNvbmdTdGFydFRpbWUobmV3IERhdGUoKSlcbiAgICBcbiAgICAvLyBNb3ZlIHNvbmcgZnJvbSBub3QgbGlzdGVuZWQgdG8gbGlzdGVuZWQgaWYgaXQncyB0aGUgZmlyc3QgdGltZVxuICAgIGNvbnN0IHNvbmdGaWxlSWQgPSBwYXJzZUludChzb25nSWQpXG4gICAgY29uc3Qgc29uZ1RvTW92ZSA9IG5vdExpc3RlbmVkU29uZ3MuZmluZChzb25nID0+IHNvbmcuZmlsZV9pZCA9PT0gc29uZ0ZpbGVJZClcbiAgICBpZiAoc29uZ1RvTW92ZSkge1xuICAgICAgc2V0TGlzdGVuZWRTb25ncyhwcmV2ID0+IFsuLi5wcmV2LCBzb25nVG9Nb3ZlXSlcbiAgICAgIHNldE5vdExpc3RlbmVkU29uZ3MocHJldiA9PiBwcmV2LmZpbHRlcihzb25nID0+IHNvbmcuZmlsZV9pZCAhPT0gc29uZ0ZpbGVJZCkpXG4gICAgfVxuICAgIFxuICAgIC8vIFVwZGF0ZSBsYXN0IHNvbmcgaW4gdXNlciBwcm9maWxlXG4gICAgYXdhaXQgdXBkYXRlTGFzdFNvbmcoc29uZ0lkKVxudHJ5IHtcbiAgYXdhaXQgc3VwYWJhc2UucnBjKCdpbmNyZW1lbnRfc29uZ192aWV3cycsIHsgc29uZ19maWxlX2lkOiBwYXJzZUludChzb25nSWQpIH0pO1xufSBjYXRjaCAoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcignRXJyb3IgaW5jcmVtZW50aW5nIHNvbmcgdmlld3M6JywgZXJyb3IpO1xufVxuXG4gIH1cblxuICAvLyBTdG9wIGN1cnJlbnQgc29uZyB0cmFja2luZyAod2hlbiBwbGF5ZXIgaXMgY2xvc2VkKVxuICBjb25zdCBzdG9wQ3VycmVudFNvbmdUcmFja2luZyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoY3VycmVudFNvbmdSZWYuY3VycmVudCAmJiBjdXJyZW50U29uZ1N0YXJ0VGltZSAmJiB1c2VyKSB7XG4gICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKVxuICAgICAgY29uc3QgbWludXRlc0xpc3RlbmVkID0gKGVuZFRpbWUuZ2V0VGltZSgpIC0gY3VycmVudFNvbmdTdGFydFRpbWUuZ2V0VGltZSgpKSAvICgxMDAwICogNjApXG4gICAgICBcbiAgICAgIGlmIChtaW51dGVzTGlzdGVuZWQgPiAwLjEpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZChtaW51dGVzTGlzdGVuZWQgKiAxMDApIC8gMTAwO1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygndXBzZXJ0X2hpc3RvcnlfbWludXRlcycsIHtcbiAgICAgIHVzZXJfdXVpZDogdXNlci5pZCxcbiAgICAgIHNvbmdfZmlsZV9pZDogcGFyc2VJbnQoY3VycmVudFNvbmdSZWYuY3VycmVudCksXG4gICAgICBtaW51dGVzOiBtaW51dGVzLFxuICAgIH0pO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgcmVjb3JkaW5nIHNvbmcgaGlzdG9yeSBvbiBzdG9wOicsIGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYPCfm5EgSGlzdG9yeSB1cGRhdGVkIG9uIHN0b3A6ICske21pbnV0ZXN9IG1pbnMgZm9yIHNvbmcgJHtjdXJyZW50U29uZ1JlZi5jdXJyZW50fWApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWNvcmRpbmcgZmluYWwgc29uZyBoaXN0b3J5OicsIGVycm9yKTtcbiAgfVxufVxuXG4gICAgfVxuXG4gICAgY3VycmVudFNvbmdSZWYuY3VycmVudCA9IG51bGxcbiAgICBzZXRDdXJyZW50U29uZ1N0YXJ0VGltZShudWxsKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIHNldExvYWRpbmcodHJ1ZSlcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtmZXRjaFNvbmdzKCksIGZldGNoUGxheWxpc3RzKCldKVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBkYXRhOicsIGVycm9yKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodXNlcikge1xuICAgICAgbG9hZERhdGEoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCBkYXRhIHdoZW4gdXNlciBsb2dzIG91dFxuICAgICAgc2V0U29uZ3MoW10pXG4gICAgICBzZXRUcmVuZGluZ1NvbmdzKFtdKVxuICAgICAgc2V0TGlzdGVuZWRTb25ncyhbXSlcbiAgICAgIHNldE5vdExpc3RlbmVkU29uZ3MoW10pXG4gICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgICBzZXRMaWtlZFNvbmdzKG5ldyBTZXQoKSlcbiAgICAgIHNldExhc3RQbGF5ZWRTb25nKG51bGwpXG4gICAgICBzZXRMb2FkaW5nKGZhbHNlKVxuICAgIH1cbiAgfSwgW3VzZXJdKVxuXG4gIHJldHVybiB7XG4gICAgc29uZ3MsXG4gICAgdHJlbmRpbmdTb25ncyxcbiAgICBsaXN0ZW5lZFNvbmdzLFxuICAgIG5vdExpc3RlbmVkU29uZ3MsXG4gICAgcGxheWxpc3RzLFxuICAgIGxpa2VkU29uZ3M6IHNvbmdzLmZpbHRlcihzb25nID0+IHNvbmcuaXNMaWtlZCksXG4gICAgbGFzdFBsYXllZFNvbmcsXG4gICAgbG9hZGluZyxcbiAgICB0b2dnbGVMaWtlLFxuICAgIGNyZWF0ZVBsYXlsaXN0LFxuICAgIGRlbGV0ZVBsYXlsaXN0LFxuICAgIHJlbmFtZVBsYXlsaXN0LFxuICAgIGFkZFNvbmdUb1BsYXlsaXN0LFxuICAgIHJlbW92ZVNvbmdGcm9tUGxheWxpc3QsXG4gICAgcmVjb3JkTGlzdGVuaW5nSGlzdG9yeSxcbiAgICBzdG9wQ3VycmVudFNvbmdUcmFja2luZyxcbiAgICByZWZyZXNoRGF0YTogKCkgPT4ge1xuICAgICAgZmV0Y2hTb25ncygpXG4gICAgICBmZXRjaFBsYXlsaXN0cygpXG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwic3VwYWJhc2UiLCJ1c2VTdXBhYmFzZURhdGEiLCJ1c2VyIiwic29uZ3MiLCJzZXRTb25ncyIsInRyZW5kaW5nU29uZ3MiLCJzZXRUcmVuZGluZ1NvbmdzIiwibGlzdGVuZWRTb25ncyIsInNldExpc3RlbmVkU29uZ3MiLCJub3RMaXN0ZW5lZFNvbmdzIiwic2V0Tm90TGlzdGVuZWRTb25ncyIsInBsYXlsaXN0cyIsInNldFBsYXlsaXN0cyIsImxpa2VkU29uZ3MiLCJzZXRMaWtlZFNvbmdzIiwiU2V0IiwibGFzdFBsYXllZFNvbmciLCJzZXRMYXN0UGxheWVkU29uZyIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiY3VycmVudFNvbmdTdGFydFRpbWUiLCJzZXRDdXJyZW50U29uZ1N0YXJ0VGltZSIsImN1cnJlbnRTb25nUmVmIiwiY29udmVydERhdGFiYXNlU29uZyIsImRiU29uZyIsImlzTGlrZWQiLCJmaWxlX2lkIiwiaW1nX2lkIiwibmFtZSIsImFydGlzdCIsImxhbmd1YWdlIiwidGFncyIsInZpZXdzIiwibGlrZXMiLCJpZCIsInRvU3RyaW5nIiwiaW1hZ2UiLCJmZXRjaFNvbmdzIiwiZGF0YSIsInNvbmdzRGF0YSIsImVycm9yIiwiZnJvbSIsInNlbGVjdCIsIm9yZGVyIiwiYXNjZW5kaW5nIiwidXNlckxpa2VkU29uZ3MiLCJsaWtlZERhdGEiLCJlcSIsIm1hcCIsIml0ZW0iLCJzb25nX2lkIiwiaGlzdG9yeURhdGEiLCJsaXN0ZW5lZFNvbmdJZHMiLCJjb252ZXJ0ZWRTb25ncyIsInNvbmciLCJoYXMiLCJzb3J0ZWRTb25ncyIsInNvcnQiLCJhIiwiYiIsImFTY29yZSIsImJTY29yZSIsInNsaWNlIiwibGlzdGVuZWQiLCJmaWx0ZXIiLCJub3RMaXN0ZW5lZCIsInVzZXJEYXRhIiwic2luZ2xlIiwibGFzdF9zb25nX2ZpbGVfaWQiLCJsYXN0U29uZyIsImZpbmQiLCJjb25zb2xlIiwiZmV0Y2hQbGF5bGlzdHMiLCJwbGF5bGlzdHNEYXRhIiwiY29udmVydGVkUGxheWxpc3RzIiwicGxheWxpc3QiLCJwbGF5bGlzdFNvbmdzIiwicGxheWxpc3Rfc29uZ3MiLCJwcyIsInNvbmdDb3VudCIsImxlbmd0aCIsInRvZ2dsZUxpa2UiLCJzb25nSWQiLCJzb25nRmlsZUlkIiwicGFyc2VJbnQiLCJpc0N1cnJlbnRseUxpa2VkIiwiZGVsZXRlIiwicnBjIiwic29uZ19maWxlX2lkIiwicHJldiIsIm5ld1NldCIsImluc2VydCIsInVzZXJfaWQiLCJhZGQiLCJwcmV2U29uZ3MiLCJwcmV2UGxheWxpc3RzIiwiY3JlYXRlUGxheWxpc3QiLCJuZXdQbGF5bGlzdCIsImRlbGV0ZVBsYXlsaXN0IiwicGxheWxpc3RJZCIsInJlbmFtZVBsYXlsaXN0IiwibmV3TmFtZSIsInVwZGF0ZSIsImFkZFNvbmdUb1BsYXlsaXN0IiwicGxheWxpc3RfaWQiLCJzb25nRXhpc3RzIiwic29tZSIsInMiLCJ1cGRhdGVkU29uZ3MiLCJyZW1vdmVTb25nRnJvbVBsYXlsaXN0IiwidXBkYXRlTGFzdFNvbmciLCJyZWNvcmRMaXN0ZW5pbmdIaXN0b3J5IiwiY3VycmVudCIsImVuZFRpbWUiLCJEYXRlIiwibWludXRlc0xpc3RlbmVkIiwiZ2V0VGltZSIsIm1pbnV0ZXMiLCJNYXRoIiwicm91bmQiLCJ1c2VyX3V1aWQiLCJsb2ciLCJzb25nVG9Nb3ZlIiwic3RvcEN1cnJlbnRTb25nVHJhY2tpbmciLCJsb2FkRGF0YSIsIlByb21pc2UiLCJhbGwiLCJyZWZyZXNoRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSupabaseData.ts\n"));

/***/ })

});